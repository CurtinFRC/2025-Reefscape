import com.revrobotics.spark.SparkBase.ControlType;
import com.revrobotics.spark.SparkBase.PersistMode;
import com.revrobotics.spark.SparkBase.ResetMode;
import com.revrobotics.spark.SparkClosedLoopController;
import com.revrobotics.spark.config.SparkMaxConfig;

public class IntakeIONeoMaxMotion extends IntakeIONeo {
    private SparkClosedLoopController intakeController = intakeNeo.getClosedLoopController();
}

public IntakeNeoMaxMotion(){
var config = new SparkMaxConfig();
config
    .smartCurrentLimit(IntakeConstants.intakeCurrentLimit)
    .idleMode(IdleMode.kBrake)
    .voltageCompensation(12.0);

// config
//     .encoder
//     .positionConversionFactor(2.0 * Math.PI / IntakeConstants.motorReduction)
//     .velocityConversionFactor((2.0 * Math.PI) / 60.0 / IntakeConstants.motorReduction)
//     .uvwMeasurementPeriod(10)
//     .uvwAverageDepth(2);

config
    .closedLoop
    .p(IntakeConstants.kP)
    .i(intakeConstants.kI)
    .d(intakeCommand.kD);

config.closedLoop.VelocityFF(1 / intakeConstants.kV);

config
    .closedLoop
    .maxMotion
    .maxVelocity(intakeConstants.intakeMaxVelocity)
    .allowedClosedLoopError();


@Override
public void achieveRPM(){
    intakeController.setReference(
        intakeConstants.goalRPM, ControlType.kPosition);
    
    }

@Override public boolean intakeAtRPM(){
    double angularVelocity = intakeEncoder.getAngularVelocity();
    return IntakeConstants.goalRPM - IntakeConstants.IntakeTolerance
    < angularVelocity && angularVelocity < IntakeConstants.goalRPM + IntakeConstants.intakeTolerance;
 }
}
